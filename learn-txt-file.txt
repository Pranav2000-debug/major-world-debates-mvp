Username Availability Check
Debounce + Race Conditions (React + Axios)

This note explains why debounce is needed, what race conditions are, and two correct ways to solve them, with focus on AbortController.

1. The Problem Weâ€™re Solving

When a user types a username during signup:

p â†’ pr â†’ pra â†’ pranav


If we call the backend on every keystroke:

Too many API calls

Slow UX

Backend load

So we use debounce.

But debounce alone introduces another issue: race conditions.

2. What Is Debounce?

Debounce delays a function call until the user stops typing.

Rules:

Each new call cancels the previous timer

Only the last call executes

Example:

Delay = 500ms

User types continuously

API call happens once, after typing stops

Debounce controls when the API is called.

3. What Is a Race Condition?

A race condition happens when:

Multiple async requests are in flight

Responses return in unpredictable order

Older responses overwrite newer intent

Example without protection

User types:

pr â†’ pra â†’ pranav


Requests sent:

Request A: pr

Request B: pra

Request C: pranav

Responses return:

pranav â†’ âŒ taken

pr â†’ âœ… available âŒ WRONG

pra â†’ âœ… available âŒ WRONG

Final UI shows:

â€œUsername availableâ€

But the actual input is pranav (taken).

ðŸ”¥ This is the race condition.

4. Why Debounce Alone Is NOT Enough

Debounce:

Reduces number of requests

âŒ Does NOT guarantee only one request is in flight

Race conditions still happen when:

Network is slow

User pauses briefly

Requests overlap

So we need race protection.

5. Two Correct Solutions
Solution A â€” Response Guard (Comparison Check)

Idea:

Only update UI if the response matches the latest username.

Concept:

Store the latest username

Ignore responses for older usernames

This works, but:

Old requests still hit backend

Responses still arrive (just ignored)

Solution B â€” AbortController (Preferred)

Idea:

Cancel old requests completely when a new one starts.

This is cleaner and more efficient.

6. AbortController â€“ Core Idea

AbortController lets us:

Cancel an in-flight network request

Prevent its response from ever resolving

Rule:

When a new username check starts, abort the previous one.

7. AbortController Flow (Step-by-Step)

Assume debounce delay = 500ms

User typing timeline
p â†’ pr â†’ pra â†’ pranav

Step 1: User stops typing at pranav

Debounce timer finishes

API request starts for pranav

AbortController A is created

Request A is in flight

Step 2: User types again: pranava

Debounce triggers again

Before making new request:

AbortController A is aborted

Request A is canceled

AbortController B is created

Request B starts

Step 3: Network responses

Request A âŒ never resolves (aborted)

Request B âœ… resolves and updates UI

No stale data. No overwrite. No race condition.

8. Why AbortController Is Cleaner
Aspect	AbortController
Cancels old requests	âœ…
Prevents stale responses	âœ…
Reduces backend load	âœ…
Explicit intent	âœ…
Slightly more setup	âš ï¸

This is why AbortController is preferred when:

Requests are frequent

Endpoint is public

UX correctness matters

9. Mental Model (Very Important)

Debounce controls when requests are sent
AbortController controls which requests are allowed to finish

They solve different problems and work together.

10. What This Does NOT Replace

Even with debounce + abort:

Backend must still validate username on signup

Availability checks are advisory only

Rule:

Signup submit is the authority. Availability checks are hints.

11. Final Summary

Debounce â†’ reduces API call frequency

AbortController â†’ prevents race conditions

Together â†’ correct, efficient, clean UX

12. One-Line Takeaway ðŸ§ 

Cancel old intent before acting on new intent.

When youâ€™re ready next, the natural steps are:

Backend rate limiting for this endpoint

Extracting this logic into a custom hook

UX decisions (when to show â€œcheckingâ€, when to stay silent)



CODE FOR ABORT CONTROLLER

const checkUsernameAvailibility = useCallback(async (username) => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }

    // create new controller
    const controller = new AbortController();
    abortControllerRef.current = controller;
    try {
      const res = await axios.get("http://localhost:4000/api/v1/auth/check-availability", {
        params: { username },
        signal: controller.signal,
      });

      setUsernameStatus(res.data.usernameAvailability ? "available" : "taken");
    } catch (error) {
      if (error.name === "CanceledError") {
        return;
      }
      setUsernameStatus(null);
    }
  }, []);

  const debouncedUsernameCheck = useCallback(
    (username) => {
      if (debouceTimer.current) {
        clearTimeout(debouceTimer.current);
      }
      setUsernameStatus("checking");

      debouceTimer.current = setTimeout(() => {
        checkUsernameAvailibility(username);
      }, 850);
    },
    [checkUsernameAvailibility]
  );

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData((prev) => ({ ...prev, [name]: value }));

    if (name === "username") {
      if (value.trim().length < 3) {
        setUsernameStatus(null);
        return;
      }

      debouncedUsernameCheck(value.trim());
    }
  };